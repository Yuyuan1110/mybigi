---
tags: programming, macro, C
alias: []
created: 2025-07-04
updated:
source:
---
# 宏 (Macro)

宏是通過 `#define` 預處理器指令定義的**程式碼片段**。宏可以是簡單的常量替換，也可以是帶參數的「宏函數」。

## 物件式宏 (Object-like Macros)

最簡單的宏，用於替換常量或簡單的表達式。

```clike
#define MAX_BUFFER_SIZE 1024 // 定義一個常量
#define PI 3.14159           // 定義一個浮點數常量
#define GREETING "Hello, World!" // 定義一個字串常量
```

## 函數式宏 (Function-like Macros)

看起來像函數一樣，但它們是**在預處理階段進行文字替換**，而不是在執行階段進行函數呼叫。

```clike
#define MAX(a, b) ((a) > (b) ? (a) : (b)) // 帶參數的宏

// 範例使用
int x = MAX(10, 20); // 預處理後會變成 int x = ((10) > (20) ? (10) : (20));
```

**宏的優點：**

- **執行效率高**：因為是直接的文字替換，沒有函數呼叫的開銷（沒有堆疊操作、參數傳遞等），對於短小且頻繁呼叫的程式碼段有潛在的效能優勢。
    
- **通用性**：不限制參數型別（因為沒有型別檢查）。
    
- **條件編譯**：唯一能用於條件編譯的方式。
    

**宏的缺點（與 `const` 或 `inline` 相比）：**

- **無型別檢查**：預處理器不關心型別，容易引入隱式型別轉換或型別不匹配問題。
    
- **潛在的副作用**：這是宏最大的陷阱。如果參數是表達式且被宏展開多次，可能會導致意外的結果。

    ```clike
    #define SQUARE(x) (x * x)
    int result = SQUARE(a++); // 展開為 (a++ * a++)，a 會被遞增兩次！
    ```
    
- **運算符優先級問題**：文字替換可能導致運算符優先級的混亂。
    
    ```clike
    #define ADD(a, b) a + b
    int res = ADD(2, 3) * 4; // 展開為 2 + 3 * 4 = 14，而不是 (2 + 3) * 4 = 20
    ```
    
    解決方法是給宏的參數和整個宏都加上括號，例如 `((a) + (b))`。
    
- **難以調試**：調試器通常只能看到展開後的程式碼，而不是宏的名稱，這使得調試變得困難。